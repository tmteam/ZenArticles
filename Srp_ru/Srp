Srp

Single responsibility principle он же принцип единой ответственности,
он же принцип единой изменчивости - крайне скользский для понимания парень и столь нервозный вопрос на собеседовании. 


Первое серьезное знакомство с этим принципом  состоялось для меня в начале первого курса, когда молодых и зеленых Нас вывезли в лес, что бы сделать из личинок студентов -  студентов настоящих.

В лесу нас разделили на группы, по 8-9 человек в каждой и устроили соревнование - какая группа быстрее выпьет бутылку водки, при условии что первый человек из группы наливает водку в стакан, второй выпивает, а третий закусывает. Выполнивший свою операцию юнит встает в конец очереди группы. 

Случай, когда размер очереди был кратен 3 и являлся хорошей реализацией Srp. (Стоит отметить что юнит, чей номер в очереди  был равен 3*N+1 получал дозу паразитного состояния и излишне высокую связанность, но это выходит за рамки данного поста)

Определение 1. Единая ответственность.

Итак. Официальное определение принципа единой ответственности (SrP) говорит о том что у каждого объекта есть cвоя ответственность и причина существования и эта ответственность у него только одна.

Рассмотрим объект "Выпивоха" (tippler).  
Для выполнения приницпа SRP разделим обязанности на троих: 
- Один наливает   (PourOperation)
- Один выпивает   (DrinkUpOperation)
- Один закусывает (TakeBiteOperation)

Каждый из участников процесса ответсвенен за одну компоненту процесса, тоесть имеет одну атомарную ответственность - Выпить, налить или закусить. 

Выпивоха же, в свою очередь является фасадом для данных операций:

сlass TipplerSrp {
   	//...
	void Do(){
		_pourOperation.Do() // налить
		_drinkUpOperation.Do() // выпить
		_takeBiteOperation.Do() // закусить
	}
}

Зачем? 

Человек-программист пишет код для человека-обезьяны, а человек-обезьяна невнимателен, глуп и вечно куда то спешит. Он может удержать и понять около 3 - 7 термов в один момент времени.
В данном случае этих термов - три, однако если мы напишем код одной простыней, то в нем появятся руки, стаканы, мордобои, гравитационные постоянные и бесконечные споры о политике и физике. И все это будет в теле одного метода. Уверен - вы видели такой код в своей практике. Не самое гуманное испытание для психики.

Также человек-обезьяна заточен на моделирование объектов реального мира в своей голове. В своем воображении он может их сталкивать, собирать из них новые объекты, и точно так же разбирать. Представьте себе старую модель машины. Вы можете в воображении открыть дверь, открутить обшивку двери и увидеть там механизмы стеклоподъемников, внутри которых будут шестерни. Но вы не можете увидеть все компоненты машины одновременно, в одном "листинге". По крайней мере "человек-обезьяна" не может.

Поэтому человеки-программисты декомпозируют сложные механизмы на набор менее сложных и работающих элементов. Однако декомпозировать можно по-разному. (например во многих старых машинах - воздуховод выходит в дверь, а в современных - сбой электроники замка не даст запуститься двигателю, что доставляет при ремонте)

Так вот - SRP это принцип, объясняющий КАК декомпозировать, тоесть где провести линию разеделения. 
 
Он говорит что декомпозировать надо по приницпу разделения "ответственности", то есть по задачам тех или иных объектов.

//!!!

Итак перечислим плюсы, которые дает мозг человека обезъянки при декомпозировании выпивохи:
- Код стал предельно ясен на каждом уровне
- Код могут писать несколько программистов сразу (каждый пишет отдельный элемент)
- Упрощается автоматическое тестирование - чем прощще элемент, тем легче его тестировать
- Появляется композиционность кода - можно заменить _drinkUpOperation на операцию, в которой выпивоха выливает жидкость под стол. Или заменить операцию наливания, на операцию, в которой вы мешаете вино и воду или водку и пиво. В зависимости от требований бизнеса вы можете все, при этом не трогая код метода Tippler.Act. 


В конце концов - из этих операций вы можете сложить обжору ( используя только _takeBitOperation), Алкоголика (используя только _drinkUpOperation напрямую из бутылки) и удовлетворить многие другие требования бизнесса.

Ой, кажется это уже OCP приницип, и я нарушил ответственность этого поста.


И конечно же минусы: 
- Придется создать больше типов. 
- Выпивоха впервые выпьет на пару часов позже чем мог бы



Определение 2. Eдиная изменчивость.

Позвольте господа! Класс выпивохи же также выполняет единую ответсвенность - он выпивает! И вообще слово "ответственность" - понятие крайне размытое. Кто то ответственен за судьбу человечества, а кто то ответсвенен за поднимание опрокинутых на полюсе пингвинов.

Рассмотрим две реализации выпывохи. Первая, указанная выше, содержит в себе три класса - Налить, выпить и закусить.

Вторая, написана через методологию "Вперед и только вперед" и содержит всю логику в методе Act:


сlass TipplerBrutForce {
	//...
	void Act(){
		// наливаем
		if(!_hand.TryDischarge(from: _bottle, to: _glass, size: _glass.Capacity))
			throw new OverdrunkException();

		// выпиваем
		if(!_hand.TryDrink(from: _glass,  size: _glass.Capacity))
			throw new OverdrunkException();

		//Закусываем
		for(int i = 0; i< 3; i++){
			var food = _foodStore.TakeOrDefault();
			if(food==null)
				throw new FoodIsOverException();
			
			_hand.TryEat(food);
			return;
		}
		throw new OverdrunkException();
	}
}

Оба этих класса,  с точки зрения стороннего наблюдателя, выглядят абсолютно одинаково и выполняют единую ответственность "выпить". 

Конфуз!

Тогда мы лезем в интернет и узнаем другое определение SRP - Приницп единой изменчивости (SingleChangeabilityPriniciple).

SCP гласит что "у модуля есть один и только один повод для изменения". Тоесть "Ответственность - это повод для изменения" 
 
(Похоже ребята, придумавшие изначальное определение были уверены в телепатических способностях человека-обезьяны)

Теперь все встает на свои места. Отдельно можно изменять процедуры наливания, выпивания и закусывания, а в самом выпивохе мы можем поменять только последовательность и состав операций, например переместив закуску перед выпиванием или добавив чтение тоста.

В подходе "Вперед и только вперед" же, все что можно поменять - меняется только в методе Act. Это может быть читабельно, в случае когда логики немного и она редко меняется, но зачастую это кончается ужасными методами по 500 строк в каждом, с количеством if -ов большим чем требуется для вступления России в нато. 

Определение 3. Локализация изменений.

Выпивохи часто не понимают почему они проснулись в чужой квартире, или где их мобильный. Пришло время добавить подробную логировку.

Начнем логировку с процесса наливания:

class PourOperation: IOperation{
	PourOperation(ILogger log /*....*/){/*...*/}
	//...
	void Act(IHand){
		_log.Log($"Before pour with {_hand} and {_bottle}");
		//Pour business logic ...
		_log.Log($"After pour with {_hand} and {_bottle}");
	}
}

Инкапсулировав ее в PourOperation мы поступили мудро, с точки зрения ответственности и  инкапсуляции, но вот с принципом изменчивости у нас теперь конфуз. Помимо самой операции которая может меняться, изменчивой становится и сама логировка. Придется отделять и делать специальный логировщик для операции наливания:

interface IPourLogger{
	void LogBefore(IHand, IBottle){}
	void LogAfter(IHand, IBottle){}
	void OnError(IHand, IBottle, Exception){}
}

class PourOperation: IOperation{
	PourOperation(IPourLogger log /*....*/){/*...*/}
	//...
	void Act(IHand){
		_log.LogBefore(_hand, _bottle);
		try{
		//... operation
		_log.LogAfter(_hand, _bottle");
		}
		catch(exception e){
			_log.OnError(_hand, _bottle, e)
		}
	}
}

Дотошный читатель заметит, что LogAfter, LogBefore и OnError - также могут меняться по отдельности и по аналогии с предыдущими действиями создаст три класса: PourLoggerBefore, PourLoggerAfter и PourErrorLogger.

А вспомнив, что операций для выпивохи три - получаем девять классов логирования. В итоге весь выпивоха состоит из 14 (!!!) классов. На этом моменте многие приходят к выводу, что SRP это сказки из розовых королевстви и уйдудт вить лапшу...

... так и не узнав о существовании третьего определения Srp: 

"Приницп единой ответственности гласит что схожие для изменения вещи должны храниться в одном месте". Тоесть если мы меняем логировку операции то мы должны это менять в одном месте.

Это очень важный момент - так как все объяснения SRP, которые были выше, говорили о том что надо дробить типы пока они дробятся, тоесть накладывало "ограничение сверху" на размер объекта, а теперь мы говорим уже и об "ограничении снизу". Иными словами SRP не просто требует "дробить пока дробится", но и не перестараться - "не раздробить связанные вещи". 


SRP - говорит не о том "насколько сильно декомпозировать", а о том "как именно декомпозировать" систему." 


Теперь должно стать полегче. Помимо того, что не надо дробить логировщик IPourLogger на три класса, мы также можем объеденить всех логировщиков в один тип:

class OperationLogger{
	public OperationLogger(string operationName){/*..*/}
	public void LogBefore(params object[] args){/*...*/}		
	public void LogAfter(params object[] args){/*..*/}
	public void LogError(params object[] args, exception e){/*..*/}
}

И если нам добавится четвертый тип операции - то для нее уже готова логировка. Код же самих операций - кристально чист, и избавлен от инфраструктурного шума.

Итого у нас есть 5 классов для решения задачи выпивания:

- Класс операции наливания
- Класс операции выпивания
- Класс операции заедания
- Класс логировки
- Класс фасада выпивохи

Каждый из них отвечает строго за одну функциональность, имеет одну причину для изменения. Все схожие для изменения правила лежат рядом.


Критерии самопроверки.

Итак у нас есть код. Как проверить выполняется  ли в нем SRP?

1) Фикс некоторого бага или добавление новой фичи затрагивает минимальное количество файлов/классов. В идеале - один 

Так как ответственность (за фичу или баг) инкапсулированна в одном файле/классе, то скорее всего вы точно знаете где искать и что править. Например:  Фича изменения вывода логировки операций, потребует изменить только логировщик. Бегать по всему остальному коду не требуется. 
 

2)Если несколько разработчиков работают над разными фичами вашего проекта, то вероятность мердж -конфликта (вероятность того, что один и тот же файл/класс будет изменен у нескольких разработчиков одновременно ) -минимальна.

Этот критерий вытекает из первого. Если при добавлении новой операции "Вылить водку под стол" - вам нужно затронуть логировщик, операцию выпивания и выливания - то есть подозрение, что ответственности разделены криво. Безусловно это не всегда возможно, но нужно стараться снизить этот показатель.   

3) При уточняющем вопросе про бизнесс логику (от разработчика или менеджера) - вы лезете строго в один класс/файл - и получаете информацию только от туда.

Если фича, правило или алгоритм существуют - то они написаны компактно и в одном месте, а не разбросаны флагами по всему пространству кода.

4) Нейминг понятен.
Наш класс или метод ответственнен за что то одно, и ответственность отражена в его названии

AllManagersManagerService - скорее всего God-класс
LocalPaymentProcessing - вероятно нет 



Примеры из жизни

Пример 1. Декомпозиция инфраструктуры и бизнесс логики.

Допустим у меня есть операция оплаты с кассы со следующей бизнесс логикой:

1)проверяем что платеж еще не оплачен, 
2)проверяем что у гостя достаточно денег.
3)Получаем подтверждение платежа у стороннего сервиса
4)Уменьшаем баланс пользователя

--- Spoiler Код метода MakeHimPay 
	void MakeHimPay(Payment payment, User user)
	{
		var stopwatch = Stopwatch.StartNew();//засекаем время начала
		Log.WriteLog("Payment operation started")
		
		try
		{
			if(payment.IsPaid)
				throw new PaymentIsAlreadyPaidException();
			if(payment.Sum > User.Balance)
				throw new UserBalanceIsLowException();
			_paymentService.GetPaymentConfirmationOrThrow(payment);
			user.DecreaseBalance(payment.Sum);
			Log.WriteLog("Payment operation finished")
			stopwatch.Stop();
			_metricSender.Send(new OperationFinished("payment",stopwatch.Elasped));
		}
		catch(Exception ex){
			Log.WriteLog("Payment failed", ex)
				stopwatch.Stop();
			_metricSender.Send(new OperationFailed("payment",ex,stopwatch.Elasped));
		}
	}
---

Из 20ти строк метода - длинна бизнесс логики - 6 строк. Это не страшно на таких объемах, но что если операции будут более сложными или речь идет о 10ти таких операция - тоесть 200 и 60 строках соответственно?


Этот метод просит что бы его показательно декомпозировали! В нашем случае - можно разделить инфраструктуру и сами операции. Для этого воспользуемся паттерном "декоратор", а метод оплаты представим как операцию.

IOperation
	+Name
	-Do()

PaymentOperation: Ioperation
	+ Name
	+ Payment
	+ User 
	- Do()

Тогда, весь инфраструктурный код можно растащить на три декоратора:

1) MetricsOperationDecorator: Ioperation
2) LogOperationDecorator : IOperation
3) ExceptionHandlingOperationDecorator: Ioperation

Каждый из этих декораторов будет иметь свою строгую ответственность

--- Spoiler - LogOperationDecorator

	class LogOperationDecorator : IOperation{
		public IOperation Operation;
		void Do(){
			Log.Write("{Operation.Name} BEGIN")
			try{

				Operation.Do();
				Log.Write("{Operation.Name} DONE")
			}
			catch(Exception e){
				Log.WriteLog("{Operation.Name} FAILED", ex)
				throw;
			}
		}
	}
---

А сама бизнесс операция будет отделена от шума


class PaymentOperation : IOperation{
	public string Name = "Payment"
	public User User;
	public Payment Payment;
	public PaymentService PaymentService;
	
	void Do(){
		if(Payment.IsPaid)
			throw new PaymentIsAlreadyPaidException();
		if(Payment.Sum > User.Balance)
			throw new UserBalanceIsLowException();
		PaymentService.GetPaymentConfirmationOrThrow(Payment);
		User.DecreaseBalance(Payment.Sum);
	}
}

Этот код можно показать менеджеру проекта или аналитику, даже без комментариев.

Бонусом к этому, мы гарантируем единообразное логирование, сбор метрик и обработку исключений для всех типов операций, а для тех операций, где правила отличается - мы можем играться набором операторов. Человек-обезьянка получает возможность поиграть в лего для бизнесс логики.

--Spoiler Если вас смутил этот код
	Вероятно некоторые моменты смутили читателя. 

	Например небрежная обработка исключений. Это было сделано осознанно, для простоты кода. 

	Так же читателя может удивить отделенная от бизнесс логики логировка. Действительно в реальном мире вам может понадобиться детальный пошаговый лог для отладки некоторой бизнесс операции, но это не повод смешивать в одно понятие базовую логировку операций "xxx BEGIN" -> "xxx DONE" и отладку кокретной операции. Это разные фичи.
--

Проверим код на критерии SRP:

1) Фикс некоторого бага или добавление новой фичи затрагивает минимальное количество файлов
- да, возможные изменения локализированы в операциях или их декораторах
2)Вероятность мердж конфликта мала 
- возможна только если несколько разработчиков работают над одной операцией.
3) При уточняющем вопросе про бизнесс логику- вы лезете строго в один класс/файл - и получаете информацию только от туда 
- да, даже при отсутствие комментариев
4) Нейминг понятен 
- да, если вы слышали про паттерны GoF



Пример 2. Ограничение снизу

Однажды мы писали сервис автоматической регистрации b2b клиента. и там был GOD -метод на 200 строк подобного содержимого:

- Сходи в 1С и заведи счет
- С этим счетом сходи к платежному модулю и заведи его там
- Проверь что аккаунт с таким счетом не создан в главном сервере
- Создай новый аккаунт
- Результат регистрации в платежном модуле и номер 1с добавь в сервис результатов регистрации
- Добавь в эту таблицу информацию об аккаунте
- Создай номер точки для этого клиента в сервисе точек. Передай в этот сервис номер 1с счета.

В этом списке было еще около 10ти бизнесс операций с жуткой связанностью.  Объект счета нужен был почти всем. Идентификатор точки и имя клиента  нужен был в половине случаев.

После часового рефакторинга, мы смогли отделить инфраструктурный код и некоторые нюансы работы с аккаунтом в отдельные модули. God метод полегчал, но осталось 100 строк кода, которые никак не хотели распутываться. 

Лишь через несколько дней начало доходить, что суть этого "полегчавшего" метода - и есть бизнесс алгоритм. И что изначальное описание ТЗ было достаточно сложным, и что нарушением SRP будет именно попытка разбить на куски этот метод, а не наоборот.


Заключение:

SRP - рассказывает нам как декомпозировать систему, но изначальная формулировка требовала изрядного навыка телепатии. Этот принцип используется не только в ООП для разделения на классы, но и в разделение методов, функций, библиотек и микросервисов.   

Для того что бы хорошо научиться декомпозировать - недостаточно прочитать эту статью. ООП и SOLID - подобны спорту, в котором нужны теория, тренировки и время. 
Нужно пробовать и ошибаться, как в сторону God-классов так и в сторону овер инжиниринга. Попробовать двигать этот ползунок, что бы ощутить обратную связь.









Для тех кто все пролистал и хочет выводов.

SRP это приницп проектирования, при котором 
- Каждый модуль(класс или метод) имеет только один повод для изменения. 
- Атомарные изменения в исходной задачи локализованны в одном модуле.

При этом определение "ответственности" следует из этих двух определений:
- Ответственность модуля это потенциальные изменения имплементированных в нем бизнесс-правил.

Ничего не понятно? Зато как на собеседованиях роляет!

Реальные примеры.







Post scriptum:

Кто то придет и скажет что 5 классов в  примере выпивохи это очень много. Специально для этих людей я написал код выпивохи в одном методе. Требования: не сломав старый функционал нужно добавить возможность говорить тосты. Наслаждайтесь, и не говорите что у вас такого кода нет ^^:

сlass Tippler {
	//...
	void Act(){
		_log.WriteDebug("Before tripple ");
		var tripplerStopwatch = Stopwatch.Start();
		try
		{
			_log.WriteDebug("Before pour with {_bottle}");
			var pourStopwatch = Stopwatch.Start();
			try{
				if(!_hand.TryDischarge(from: _bottle, to: _glass, size: _glass.Capacity))
					throw new OverdrinkException();
				_log.WriteDebug("Finish pour with {_bottle} in {pourStopwatch.TotalMilliseconds}");
			}
			catch(Exception e){
				_log.WriteError("Pour error {e} with bottle {_bottle} in {pourStopwatch.TotalMilliseconds}")
				throw;
			}	
			pourStopwatch.Stop();

			_log.WriteDebug("Before drink with {_bottle}");
			var drinkStopwatch = Stopwatch.Start();
			try{
				if(!_hand.TryDrink(from: _glass,  size: _glass.Capacity))
					throw new OverdrinkException();
				_log.WriteDebug("Finish drink with {_bottle} in {pourStopwatch.TotalMilliseconds}");
			}
			catch(Exception e){
				_log.WriteError("Drink error {e} with bottle {_bottle} in {drinkStopwatch.TotalMilliseconds}");		
				throw;
			}
			
			try{
				_log.WriteDebug("Before TakeBite.");
				var takeBiteStopwatch = Stopwatch.Start();

				for(int i = 0; i< 3; i++){
					var food = _foodStore.TakeOrDefault();
					if(food==null)
						throw new FoodIsOverException();
				
					_hand.TryEat(food);
					_log.WriteDebug("finish TakeBite in {takeBiteStopwatch.TotalMilliseconds}");
					return; 
				}

				throw new OverdrinkException();
			}
			catch(Exception e){
				_log.WriteError("Error TakeBite {e.Message} in {takeBiteStopwatch.TotalMilliseconds}");
				throw;
			}
			_log.WriteDebig("Finish tripple in {tripple.TotalMilliseconds}")
		}
		catch(Exception e){
			_log.WriteError("Error Trippler {e.Message} in (tripple.TotalMillisecons) )
		}
	}
}
